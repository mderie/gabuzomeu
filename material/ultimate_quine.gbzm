
; Hypothesis we don't allow BIRD GA, BU
; So we stick to the alternate birds principle

; Step 0 : define the "data" part

;CALC GA, #BUGABUMEU ; 'G' = 71
;BIRD BU
;LIFT BU
;CALC GA, #BUGAGAZO ; 'B' = 66
;BIRD ZO
;LIFT ZO
;CALC GA, #BUBUZOZO ; 'Z' = 90
;BIRD BU
;LIFT BU
;CALC GA, #BUGAMEUBU ; 'M' = 77
CALC GA, #MEUZOZO BIRD BU LIFT BU CALC GA, #BUZOBUBU BIRD ZO LIFT ZO CALC GA, #BUMEUZOGA BIRD BU LIFT BU CALC GA, #BUMEUGAGA BIRD ZO LIFT ZO CALC GA, #BUZOGABU BIRD BU LIFT BU CALC GA, #BUZOMEUZO BIRD ZO LIFT ZO CALC GA, #BUZOBUGA BIRD BU LIFT BU CALC GA, #BUBUMEUMEU BIRD ZO LIFT ZO CALC GA, #BUZOMEUGA BIRD BU LIFT BU CALC GA, #BUZOMEUMEU BIRD ZO LIFT ZO CALC GA, #BUZOMEUMEU BIRD BU LIFT BU CALC GA, #BUMEUGAGA BIRD ZO LIFT ZO CALC GA, #BUBUMEUMEU BIRD BU LIFT BU CALC GA, #BUZOGAZO BIRD ZO LIFT ZO CALC GA, #BUMEUBUBU BIRD BU LIFT BU CALC GA, #ZOGAGA BIRD ZO LIFT ZO CALC GA, #BUGAGAMEU BIRD BU LIFT BU CALC GA, #BUGAGABU BIRD ZO LIFT ZO CALC GA, #BUGAMEUGA BIRD BU LIFT BU CALC GA, #BUGAGAMEU BIRD ZO LIFT ZO CALC GA, #ZOGAGA BIRD BU LIFT BU CALC GA, #BUGAMEUBU BIRD ZO LIFT ZO CALC GA, #BUGABUBU BIRD BU LIFT BU CALC GA, #BUBUBUBU BIRD ZO LIFT ZO CALC GA, #ZOMEUGA BIRD BU LIFT BU CALC GA, #ZOGAGA BIRD ZO LIFT ZO CALC GA, #ZOGAMEU BIRD BU LIFT BU CALC GA, #BUGAGAZO BIRD ZO LIFT ZO CALC GA, #BUBUBUBU BIRD BU LIFT BU CALC GA, #BUGABUMEU BIRD ZO LIFT ZO
CALC GA, #BUGAGABU ; Care the last one can't be followed by BIRD & LIFT !

; Step 1 : we need to rewind the entire data structure

:initial_rewind
HEAD BU, initial_rewind_bu
HEAD ZO, initial_rewind_zo
JUMP expand_loop ; End of the initial rewind

:initial_rewind_bu
LIFT BU
JUMP initial_rewind ; Continue the rewinding

:initial_rewind_zo
LIFT ZO
JUMP initial_rewind  ; Continue the rewinding

; Step 2 : now we will dump the expanded version of the data structure

:expand_loop
CALC MEU, #BUGAGAMEUBUGAGABUBUGAMEUGABUGAGAMEUGAZOGAGABUGABUMEUBUGAGABUGAZOMEUGA ; = "CALC GA," We use here the default base !
DUMP MEU ; We could remove the big number support by "calculating" then dumping each byte, but this extends the real code part and so the length of the data to encode...
BASE #BUGA
DUMP GA
BASE #BUGAGAGAGA

TAIL BU, expand_loop_bu
TAIL ZO, expand_loop_zo
JUMP final_rewind

:expand_loop_bu
CALC MEU, #BUGAGAZOBUGAZOBUBUBUGAZOBUGABUGAGAZOGAGABUGAGAZOBUBUBUBUGAZOGAGABUGAMEUBUBUGAMEUMEUBUBUBUZOBUGABUBUGAZOGAGABUGAGAZOBUBUBUBU ; = "BIRD BU LIFT BU" TODO: Add CR LF ? Remove spaces ?
DUMP MEU
LIFT BU
JUMP expand_loop

:expand_loop_zo
CALC MEU, #BUGAGAZOBUGAZOBUBUBUGAZOBUGABUGAGAZOGAGABUBUZOZOBUGAMEUMEUGAZOGAGABUGAMEUBUBUGAMEUMEUBUBUBUZOBUGABUBUGAZOGAGABUBUZOZOBUGAMEUMEU ; = "BIRD ZO LIFT ZO"
DUMP MEU
LIFT ZO
JUMP expand_loop

; Step 3 : again we need a complete rewind

:final_rewind
HEAD BU, final_rewind_bu
HEAD ZO, final_rewind_zo
JUMP compact_loop

:final_rewind_bu
LIFT BU
JUMP final_rewind

:final_rewind_zo
LIFT ZO
JUMP final_rewind

; Step 4 : finally we can dump the compacted version

:compact_loop

DUMP GA

TAIL BU, compact_loop_bu
TAIL ZO, compact_loop_zo
JUMP eof

:compact_loop_bu
LIFT BU
JUMP compact_loop

:compact_loop_zo
LIFT ZO
JUMP compact_loop

; That's all folks !

:eof
